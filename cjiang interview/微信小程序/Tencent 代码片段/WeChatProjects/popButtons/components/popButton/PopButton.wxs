/**
 * state的变量说明如下: 
 * maxWidth 最大可移动宽度
 * maxHeight 最大可移动高度
 * windowWidth 屏幕宽度
 * windowHeight 屏幕高度
 * buttonWidth 按钮区宽度
 * buttonHeight 按钮区高度
 * menuList 菜单列表
 * start 是否开始触摸 这个布尔值是防止start的时候没有 maxHeight 和 maxWidth，而后续事件的时候却有了
 * move 是否有滑动，点击结束的时候如果没有滑动过，则当做点击
 * offset 偏移量，每次移动结束后会保存下偏移量
 * startPoint 触摸起始点，move和end的时候根据起始点、当前点、上一次偏移量计算当前偏移量。公式为：当前偏移量 = 上次偏移量 + 当前点 - 起始点
 * openMenu 菜单是否展开
 */

/**
 * 计算两个点之间的距离
 */ 
function getDistance(a, b) {
  return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2))
}

/**
 * 未触摸状态下的位置处理
 */
function reset(state,instance,withAnimation) {
  // 松手的时候计算停靠位置，停靠原则是停靠最近的那个边缘
  var current = {
    x: state.offset[0],
    y: state.offset[1],
  }
  var halfX = state.maxWidth / 2
  var halfY = state.maxHeight / 2
  if (current.x < 0) current.x = 0
  if (current.y < 0) current.y = 0
  if (current.x > state.maxWidth) current.x = state.maxWidth
  if (current.y > state.maxHeight) current.y = state.maxHeight

  // 这4个margin是当前位置距离4个边的位置
  var marginLeft = current.x
  var marginTop = current.y
  var marginRight = state.maxWidth - current.x
  var marginBottom = state.maxHeight - current.y
  var min = Math.min(marginLeft, marginTop, marginRight, marginBottom)
  var duration = 0.3 // 动态计算动画时长，保证移动速度固定，计算公式是 最大时长*(边距/移动到该边的最大长度)
  if (min == marginLeft) {
    duration = duration * (marginLeft / halfX).toFixed(2)
    current.x = 0
  } else if (min == marginTop) {
    duration = duration * (marginTop / halfX).toFixed(2)
    current.y = 0
  } else if (min == marginRight) {
    duration = duration * (marginRight / halfX).toFixed(2)
    current.x = state.maxWidth
  } else if (min == marginBottom) {
    duration = duration * (marginBottom / halfX).toFixed(2)
    current.y = state.maxHeight
  }
  state.offset = [current.x, current.y]
  instance.setStyle({
    transition: withAnimation?"transform " + duration + "s":"none",
    transform: "translate(" + current.x + "px," + current.y + "px)",
  })
}

/**
 * 隐藏子菜单
 */
function hide(state,instance){
  var length = state.menuList.length
  for (var i = 0; i < length; i++) {
    var menu = instance.selectComponent("#menu" + i)
    menu.setStyle({
      transform: "translate(0,0) scale(0.8)"
    })
  }
}
module.exports = {
  start: function(e, instance) {
    var state = e.instance.getState()
    if (!state.maxHeight || !state.maxWidth) return
    state.start = true // 
    if (!state.menuList) state.menuList = []
    if (!state.offset) state.offset = [0, 0]
    state.startPoint = [e.changedTouches[0].pageX, e.changedTouches[0].pageY]
  },
  move: function(e, instance) {
    var state = e.instance.getState()
    if (!state.start) return
    if (state.openMenu) { // 如果菜单是展开状态，则滑动的时候先收起，无论滑动距离多少都收起
      hide(state,instance)
      state.openMenu = false
      state.move = true
    }
    // 偏移绝对值，只有滑动的时候两个方向至少有一个变化超过3px的时候才算滑动过
    var offsetAbs = [
      Math.abs(e.changedTouches[0].pageX - state.startPoint[0]),
      Math.abs(e.changedTouches[0].pageY - state.startPoint[1])
    ]
    if (offsetAbs[0] > 3 || offsetAbs[1] > 3) state.move = true;
    var currentX = state.offset[0] + e.changedTouches[0].pageX - state.startPoint[0]
    var currentY = state.offset[1] + e.changedTouches[0].pageY - state.startPoint[1]

    // 边界处理
    if (currentX < 0) currentX = 0
    if (currentY < 0) currentY = 0
    if (currentX > state.maxWidth) currentX = state.maxWidth
    if (currentY > state.maxHeight) currentY = state.maxHeight

    e.instance.setStyle({
      transform: "translate(" + currentX + "px," + currentY + "px)",
    })
  },
  end: function(e, instance) {
    var state = e.instance.getState()
    if (!state.start) return
    if (state.move) {
      var currentX = state.offset[0] + e.changedTouches[0].pageX - state.startPoint[0]
      var currentY = state.offset[1] + e.changedTouches[0].pageY - state.startPoint[1]
      state.offset=[currentX,currentY]
      // 松手的时候计算停靠位置，停靠原则是停靠最近的那个边缘
      reset(state,e.instance,true)
    } else {
      var length = state.menuList.length
      if (!length) return
      if (state.openMenu) {
        var touchPoint = {
          x: e.changedTouches[0].pageX - state.offset[0],
          y: e.changedTouches[0].pageY - state.offset[1],
        }
        var touchIndex = -1
        // 初始化最短范围为按钮的对角线为直径的圆
        var minDistance = getDistance({
          x: 0,
          y: 0
        }, {
          x: state.buttonWidth / 2,
          y: state.buttonHeight / 2
        })
        var centerList = state.centerList
        for (var i = 0; i < length; i++) {
          var distance = getDistance(touchPoint, centerList[i])
          if (distance < minDistance) {
            minDistance = distance
            touchIndex = i
          }
        }
        if (touchIndex != -1) {
          instance.triggerEvent("change", {
            index: touchIndex
          })
        }
        hide(state,instance)
        state.openMenu = false
      } else {
        var offset = state.offset
        var buttonWidth = state.buttonWidth
        // 子按钮伸出去的长度，这里我写的是 按钮对角线长度
        var spreadLength = Math.sqrt(Math.pow(buttonWidth, 2) * 2)
        // 下面这一坨if else的是计算当前位置展开子按钮时候的起点角度和终点角度，排列方式始终采用逆时针
        var startDeg = 0
        var endDeg = 0
        if (offset[0] == 0) {
          if (offset[1] >= spreadLength) {
            endDeg = 90
          } else {
            endDeg = Math.asin(offset[1] / spreadLength) / Math.PI * 180
          }
          if (offset[1] + spreadLength <= state.maxHeight) {
            startDeg = -90
          } else {
            startDeg = Math.asin((offset[1] - state.maxHeight) / spreadLength) / Math.PI * 180
          }
        } else if (offset[1] == 0) {
          if (offset[0] + spreadLength <= state.maxWidth) {
            endDeg = 0
          } else {
            endDeg = -Math.acos((state.maxWidth - offset[0]) / spreadLength) / Math.PI * 180
          }
          if (offset[0] >= spreadLength) {
            startDeg = -180
          } else {
            startDeg = -Math.acos(-offset[0] / spreadLength) / Math.PI * 180
          }
        } else if (offset[0] == state.maxWidth) {
          if (offset[1] + spreadLength <= state.maxHeight) {
            endDeg = -90
          } else {
            endDeg = -Math.acos((state.maxHeight - offset[1]) / spreadLength) / Math.PI * 180 - 90
          }
          if (offset[1] >= spreadLength) {
            startDeg = -270
          } else {
            startDeg = -Math.asin(offset[1] / spreadLength) / Math.PI * 180 - 180
          }
        } else if (offset[1] == state.maxHeight) {
          if (offset[0] >= spreadLength) {
            endDeg = 180
          } else {
            endDeg = Math.acos(-offset[0] / spreadLength) / Math.PI * 180
          }
          if (offset[0] + spreadLength <= state.maxWidth) {
            startDeg = 0
          } else {
            startDeg = Math.acos((state.maxWidth - offset[0]) / spreadLength) / Math.PI * 180
          }
        }
        // 每个子按钮的两侧等间距，起始角度先间隔1个步长，之后每个按钮之间间隔2个步长
        var step = (endDeg - startDeg) / (length * 2)
        var currentDeg = startDeg + step //
        var centerList = []
        for (var i = 0; i < length; i++) {
          var x = spreadLength * Math.cos(currentDeg * Math.PI / 180)
          var y = -spreadLength * Math.sin(currentDeg * Math.PI / 180)
          var menu = instance.selectComponent("#menu" + i)
          menu.setStyle({
            transform: "translate(" + x + "px," + y + "px) scale(1)"
          })
          centerList.push({
            x: x + state.buttonWidth / 2,
            y: y + state.buttonHeight / 2
          })
          currentDeg += step * 2
        }
        state.openMenu = true
        state.centerList = centerList
      }
    }
    state.start = false
    state.move = false

  },
  init: function(newValue, oldValue, ownInstance, instance) {
    if (!newValue) return
    var state = instance.getState()
    state.maxWidth = newValue.maxWidth
    state.maxHeight = newValue.maxHeight
    state.windowWidth = newValue.windowWidth
    state.windowHeight = newValue.windowHeight
    state.buttonWidth = newValue.buttonWidth
    state.buttonHeight = newValue.buttonHeight
    state.init = true
    // 去掉隐藏的样式
    instance.removeClass("hide")
    if(state.needReset){
      reset(state,instance,false)
      state.needReset = false
    }
  },
  changeProps: function (newValue, oldValue, ownInstance, instance) {
    if (!newValue) return
    var state = instance.getState()
    if (newValue.menuList) {
      state.menuList = newValue.menuList
      if (state.init) {
        hide(state,instance)
      }
    }
    if (newValue.offset) {
      state.offset = newValue.offset
      if (state.init) {
        reset(state,instance,false)
      } else {
        state.needReset = true
      }
    }
    
  }
}