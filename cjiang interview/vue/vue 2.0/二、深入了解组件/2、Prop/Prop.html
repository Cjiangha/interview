<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <div id="app">
        <blog-post post-title="hello!"></blog-post>
    </div>
  </body>
  <script src="../vue.js"></script>
  <script>
    /*
        1、Prop 的大小写 (camelCase vs kebab-case)
        2、Prop 类型
         *  字符串数组props
          props:['title','likes','isPublished','commentIds','author']
        * 对象 props
         props:{
             title:String,
             likes:Number,
             isPublished:Boolean,
             commentIds:Array,
             author:Object,
             callback:Function,
             contactsPromise:Promise //or any other constructor
         }
         3、传递静态或动态 Prop
            传入一个数字
            传入一个布尔值
            传入一个数组
            传入一个对象
            传入一个对象的所有的property
          
         4、单向数据流
             所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：父级 prop 的更新会向下流动到子组件中，
             但是反过来则不行。这样会防止从子组件意外变更父级组件的状态，从而导致你的应用的数据流向难以理解。

             具体的case：
             1）、这个 prop 用来传递一个初始值；这个子组件接下来希望将其作为一个本地的 prop 数据来使用。
             在这种情况下，最好定义一个本地的 data property 并将这个 prop 用作其初始值：
             2）、这个 prop 以一种原始的值传入且需要进行转换。
         5、Prop 验证

            // 基础的类型检查 (`null` 和 `undefined` 会通过任何类型验证)
            propA: Number,
            // 多个可能的类型
            propB: [String, Number],
            // 必填的字符串
            propC: {
              type: String,
              required: true
            },
            // 带有默认值的数字
            propD: {
              type: Number,
              default: 100
            },
            // 带有默认值的对象
            propE: {
              type: Object,
              // 对象或数组默认值必须从一个工厂函数获取
              default: function () {
                return { message: 'hello' }
              }
            },
            // 自定义验证函数
            propF: {
              validator: function (value) {
                // 这个值必须匹配下列字符串中的一个
                return ['success', 'warning', 'danger'].indexOf(value) !== -1
              }
            }

         6、非 Prop 的 Attribute
            一个非 prop 的 attribute 是指传向一个组件，但是该组件并没有相应 prop 定义的 attribute。

            因为显式定义的 prop 适用于向一个子组件传入信息，然而组件库的作者并不总能预见组件会被用于怎样的场景。
            这也是为什么组件可以接受任意的 attribute，而这些 attribute 会被添加到这个组件的根元素上。
            
    }
    */    
    Vue.component("blog-post", {
      // 在 JavaScript 中是 camelCase 的
      props: ["postTitle"],
      template: "<h3>{{ postTitle }}</h3>",
    });
    new Vue({
        el:'#app'
    })

   


  </script>
</html>
