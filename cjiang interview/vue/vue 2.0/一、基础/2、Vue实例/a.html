<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <div id="app">
        <p>{{foo}}</p>
        <button v-on:click="foo = 'baz'">Change it</button>
    </div>
    <div id="example">

    </div>

</body>
<script src="https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js"></script>
<script>
    
    // 1
    // var data = {a:1}
    // var vm = new Vue({
    //     data
    // })
    // /* 
    //     当这些数据改变时，视图会进行重渲染。值得注意的是只有当实例被创建时就已经存在于 
    //     data 中的 property 才是响应式的。也就是说如果你添加一个新的 property，比如：
    // */ 
    // vm.a == data.a 
    // console.log(vm.a == data.a)


    // // 2
    // var obj={
    //     foo:'bar'
    // }

    // Object.freeze(obj)  //Object.freeze() 方法可以冻结一个对象。不能修改该对象已有属性的可枚举性、可配置性、可写性，以及不能修改已有属性的值。

    // new Vue({
    //     el:'#app',
    //     data:obj
    // })

    //3、
    var data = {a:1}
    var vm = new Vue({
        el:'#example',
        data:data ,
        // tips :不要在 选项property 或者回调上使用箭头函数
        created: function(){
            // 'this' 指向 vm 实例
            console.log('a is: ', this.a)
        }
    })

    vm.$data === data // => true
    vm.$el === document.getElementById('example') // =>true

    console.log('vm.$data === data',vm.$data === data)
    console.log("vm.$el === document.getElementById('example')",vm.$el === document.getElementById('example'))

    // $watch 是一个实例方法
    vm.$watch('a',function (newValue,oldValue){
        // 这个回调将在'vm.a' 改变后调用
        vm.a = 2;
        console.log(vm.a)
    })


    /*
        生命周期
            beforeCreate create beforemouted
            mouted beforeDestroy destroyed


    
    
    */ 




</script>
</html>